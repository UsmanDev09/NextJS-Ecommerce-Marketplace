import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var getBoundingClientRect = function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    left: Math.ceil(rect.left),
    width: Math.ceil(rect.width)
  };
};

var sortNumList = function sortNumList(arr) {
  return [].concat(arr).sort(function (a, b) {
    return Number(a) - Number(b);
  });
};

var useGetLatest = function useGetLatest(val) {
  var ref = React.useRef(val);
  ref.current = val;
  return React.useCallback(function () {
    return ref.current;
  }, []);
};

var linearInterpolator = {
  getPercentageForValue: function getPercentageForValue(val, min, max) {
    return Math.max(0, Math.min(100, (val - min) / (max - min) * 100));
  },
  getValueForClientX: function getValueForClientX(clientX, trackDims, min, max) {
    var left = trackDims.left,
        width = trackDims.width;
    var percentageValue = (clientX - left) / width;
    var value = (max - min) * percentageValue;
    return value + min;
  }
};
function useRanger(_ref) {
  var _ref$interpolator = _ref.interpolator,
      interpolator = _ref$interpolator === void 0 ? linearInterpolator : _ref$interpolator,
      _ref$tickSize = _ref.tickSize,
      tickSize = _ref$tickSize === void 0 ? 10 : _ref$tickSize,
      values = _ref.values,
      min = _ref.min,
      max = _ref.max,
      controlledTicks = _ref.ticks,
      steps = _ref.steps,
      onChange = _ref.onChange,
      onDrag = _ref.onDrag,
      stepSize = _ref.stepSize;

  var _React$useState = React.useState(null),
      activeHandleIndex = _React$useState[0],
      setActiveHandleIndex = _React$useState[1];

  var _React$useState2 = React.useState(),
      tempValues = _React$useState2[0],
      setTempValues = _React$useState2[1];

  var getLatest = useGetLatest({
    activeHandleIndex: activeHandleIndex,
    onChange: onChange,
    onDrag: onDrag,
    values: values,
    tempValues: tempValues
  });
  var trackElRef = React.useRef();
  var getValueForClientX = React.useCallback(function (clientX) {
    var trackDims = getBoundingClientRect(trackElRef.current);
    return interpolator.getValueForClientX(clientX, trackDims, min, max);
  }, [interpolator, max, min]);
  var getNextStep = React.useCallback(function (val, direction) {
    if (steps) {
      var currIndex = steps.indexOf(val);
      var nextIndex = currIndex + direction;

      if (nextIndex >= 0 && nextIndex < steps.length) {
        return steps[nextIndex];
      } else {
        return val;
      }
    } else {
      if (process.env.NODE_ENV !== 'production') {
        if (typeof stepSize === 'undefined') {
          throw new Error('Warning: The option `stepSize` is expected in `useRanger`, but its value is `undefined`');
        }
      }

      var nextVal = val + stepSize * direction;

      if (nextVal >= min && nextVal <= max) {
        return nextVal;
      } else {
        return val;
      }
    }
  }, [max, min, stepSize, steps]);
  var roundToStep = React.useCallback(function (val) {
    var left = min;
    var right = max;

    if (steps) {
      steps.forEach(function (step) {
        if (step <= val && step > left) {
          left = step;
        }

        if (step >= val && step < right) {
          right = step;
        }
      });
    } else {
      if (process.env.NODE_ENV !== 'production') {
        if (typeof stepSize === 'undefined') {
          throw new Error('Warning: The option `stepSize` is expected in `useRanger`, but its value is `undefined`');
        }
      }

      while (left < val && left + stepSize < val) {
        left += stepSize;
      }

      right = Math.min(left + stepSize, max);
    }

    if (val - left < right - val) {
      return left;
    }

    return right;
  }, [max, min, stepSize, steps]);
  var handleDrag = React.useCallback(function (e) {
    var _getLatest = getLatest(),
        activeHandleIndex = _getLatest.activeHandleIndex,
        onDrag = _getLatest.onDrag;

    var clientX = e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX;
    var newValue = getValueForClientX(clientX);
    var newRoundedValue = roundToStep(newValue);
    var newValues = [].concat(values.slice(0, activeHandleIndex), [newRoundedValue], values.slice(activeHandleIndex + 1));

    if (onDrag) {
      onDrag(newValues);
    } else {
      setTempValues(newValues);
    }
  }, [getLatest, getValueForClientX, roundToStep, values]);
  var handleKeyDown = React.useCallback(function (e, i) {
    var _getLatest2 = getLatest(),
        values = _getLatest2.values,
        _getLatest2$onChange = _getLatest2.onChange,
        onChange = _getLatest2$onChange === void 0 ? function () {} : _getLatest2$onChange; // Left Arrow || Right Arrow


    if (e.keyCode === 37 || e.keyCode === 39) {
      setActiveHandleIndex(i);
      var direction = e.keyCode === 37 ? -1 : 1;
      var newValue = getNextStep(values[i], direction);
      var newValues = [].concat(values.slice(0, i), [newValue], values.slice(i + 1));
      var sortedValues = sortNumList(newValues);
      onChange(sortedValues);
    }
  }, [getLatest, getNextStep]);
  var handlePress = React.useCallback(function (e, i) {
    setActiveHandleIndex(i);

    var handleRelease = function handleRelease(e) {
      var _getLatest3 = getLatest(),
          tempValues = _getLatest3.tempValues,
          values = _getLatest3.values,
          _getLatest3$onChange = _getLatest3.onChange,
          onChange = _getLatest3$onChange === void 0 ? function () {} : _getLatest3$onChange,
          _getLatest3$onDrag = _getLatest3.onDrag,
          onDrag = _getLatest3$onDrag === void 0 ? function () {} : _getLatest3$onDrag;

      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('touchmove', handleDrag);
      document.removeEventListener('mouseup', handleRelease);
      document.removeEventListener('touchend', handleRelease);
      var sortedValues = sortNumList(tempValues || values);
      onChange(sortedValues);
      onDrag(sortedValues);
      setActiveHandleIndex(null);
      setTempValues();
    };

    document.addEventListener('mousemove', handleDrag);
    document.addEventListener('touchmove', handleDrag);
    document.addEventListener('mouseup', handleRelease);
    document.addEventListener('touchend', handleRelease);
  }, [getLatest, handleDrag]);
  var getPercentageForValue = React.useCallback(function (val) {
    return interpolator.getPercentageForValue(val, min, max);
  }, [interpolator, max, min]); // Build the ticks

  var ticks = React.useMemo(function () {
    var ticks = controlledTicks || steps;

    if (!ticks) {
      ticks = [min];

      while (ticks[ticks.length - 1] < max - tickSize) {
        ticks.push(ticks[ticks.length - 1] + tickSize);
      }

      ticks.push(max);
    }

    return ticks.map(function (value, i) {
      return {
        value: value,
        getTickProps: function getTickProps(_temp) {
          var _ref2 = _temp === void 0 ? {} : _temp,
              _ref2$key = _ref2.key,
              key = _ref2$key === void 0 ? i : _ref2$key,
              _ref2$style = _ref2.style,
              style = _ref2$style === void 0 ? {} : _ref2$style,
              rest = _objectWithoutPropertiesLoose(_ref2, ["key", "style"]);

          return _extends({
            key: key,
            style: _extends({
              position: 'absolute',
              width: 0,
              left: getPercentageForValue(value) + "%",
              transform: "translateX(-50%)"
            }, style)
          }, rest);
        }
      };
    });
  }, [controlledTicks, getPercentageForValue, max, min, steps, tickSize]);
  var segments = React.useMemo(function () {
    var sortedValues = sortNumList(tempValues || values);
    return [].concat(sortedValues, [max]).map(function (value, i) {
      return {
        value: value,
        getSegmentProps: function getSegmentProps(_temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2,
              _ref3$key = _ref3.key,
              key = _ref3$key === void 0 ? i : _ref3$key,
              _ref3$style = _ref3.style,
              style = _ref3$style === void 0 ? {} : _ref3$style,
              rest = _objectWithoutPropertiesLoose(_ref3, ["key", "style"]);

          var left = getPercentageForValue(sortedValues[i - 1] ? sortedValues[i - 1] : min);
          var width = getPercentageForValue(value) - left;
          return _extends({
            key: key,
            style: _extends({
              position: 'absolute',
              left: left + "%",
              width: width + "%"
            }, style)
          }, rest);
        }
      };
    });
  }, [getPercentageForValue, max, min, tempValues, values]);
  var handles = React.useMemo(function () {
    return (tempValues || values).map(function (value, i) {
      return {
        value: value,
        active: i === activeHandleIndex,
        getHandleProps: function getHandleProps(_temp3) {
          var _ref4 = _temp3 === void 0 ? {} : _temp3,
              _ref4$key = _ref4.key,
              key = _ref4$key === void 0 ? i : _ref4$key,
              ref = _ref4.ref,
              _ref4$innerRef = _ref4.innerRef,
              _onKeyDown = _ref4.onKeyDown,
              _onMouseDown = _ref4.onMouseDown,
              _onTouchStart = _ref4.onTouchStart,
              _ref4$style = _ref4.style,
              style = _ref4$style === void 0 ? {} : _ref4$style,
              rest = _objectWithoutPropertiesLoose(_ref4, ["key", "ref", "innerRef", "onKeyDown", "onMouseDown", "onTouchStart", "style"]);

          return _extends({
            key: key,
            onKeyDown: function onKeyDown(e) {
              e.persist();
              handleKeyDown(e, i);
              if (_onKeyDown) _onKeyDown(e);
            },
            onMouseDown: function onMouseDown(e) {
              e.persist();
              handlePress(e, i);
              if (_onMouseDown) _onMouseDown(e);
            },
            onTouchStart: function onTouchStart(e) {
              e.persist();
              handlePress(e, i);
              if (_onTouchStart) _onTouchStart(e);
            },
            role: 'slider',
            'aria-valuemin': min,
            'aria-valuemax': max,
            'aria-valuenow': value,
            style: _extends({
              position: 'absolute',
              top: '50%',
              left: getPercentageForValue(value) + "%",
              zIndex: i === activeHandleIndex ? '1' : '0',
              transform: 'translate(-50%, -50%)'
            }, style)
          }, rest);
        }
      };
    });
  }, [activeHandleIndex, getPercentageForValue, handleKeyDown, handlePress, min, max, tempValues, values]);

  var getTrackProps = function getTrackProps(_temp4) {
    var _ref5 = _temp4 === void 0 ? {} : _temp4,
        _ref5$style = _ref5.style,
        style = _ref5$style === void 0 ? {} : _ref5$style,
        _ref6 = _ref5.ref,
        rest = _objectWithoutPropertiesLoose(_ref5, ["style", "ref"]);

    return _extends({
      ref: function ref(el) {
        trackElRef.current = el;

        if (_ref6) {
          if (typeof _ref6 === 'function') {
            _ref6(el);
          } else {
            _ref6.current = el;
          }
        }
      },
      style: _extends({
        position: 'relative',
        userSelect: 'none'
      }, style)
    }, rest);
  };

  return {
    activeHandleIndex: activeHandleIndex,
    getTrackProps: getTrackProps,
    ticks: ticks,
    segments: segments,
    handles: handles
  };
}

export { useRanger };
//# sourceMappingURL=react-ranger.mjs.map
